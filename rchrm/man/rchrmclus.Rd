% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/r_chrm functions.R
\name{rchrmclus}
\alias{rchrmclus}
\title{Recursive Clustering by Heterogeneity of repeated Measures R-CHRM}
\usage{
rchrmclus(
  arr,
  id,
  timevector,
  init_cols = 1,
  B = 100,
  method = "original",
  nlimit = 20,
  imp = "copyMean.locf",
  algo = "kmeans",
  dis = "euclidean",
  gapdis = "euclidean",
  gapmethod = "Tibs2001SEmax",
  covmethod = "pearson",
  var_a = TRUE,
  cor_o = TRUE,
  cor_t = TRUE,
  novarcor = FALSE,
  standard = TRUE,
  fixmat = FALSE
)
}
\arguments{
\item{arr}{a list of matrices of the same dimensions. Longitudinal variable in a wide format.}

\item{id}{a vector of IDs associated with each individual in the order of the matrix. 'id' and matrices should be sorted according to 'id'.}

\item{timevector}{The visits or time points associated with each column for each variable. Example: timevector = C(0,1,2,3)}

\item{init_cols}{The number of visits (columns) should the algorithm start with. 1,2,3}

\item{B}{the number of uniform samples to be drawn for the GAP statistics}

\item{method}{what version of the Tibshirani Gap statistic to use "original" or "scaledPCA"}

\item{nlimit}{number limit to restrict further clustering if number of sample is equal to or less than the specified.}

\item{imp}{Method of imputation ("copyMean.locf") for intermittent missing, if present. See 'kml' package for additional methods.}

\item{algo}{what algorithm to use to partition clusters: "kmeans", "kmedians", "kmeans2", "kmedians2", "pam", etc.... Note that kmeans2 and kmedians2 performs kmeans and kmedians 20 times with different starting points and selects the cluster partition with the best objective function.}

\item{dis}{the distance to use ("euclidean","manhattan" , "mahalanobis","minkowski", "maximum", "canberra", "binary","mahalanobis-ZCA", "mahalanobis-ZCA-cor","mahalanobis-PCA", "mahalanobis-PCA-cor", "mahalanobis-Cholesky")}

\item{gapdis}{the distance to use in the gap statistic function. Same options as "dis". Keep as euclidean if "dis" is already non-euclidean.}

\item{gapmethod}{which method to use to obtain optimal clusters ("Tibs2001SEmax", "globalSEmax", "fixed", "RamdomForrest")}

\item{covmethod}{Correlation method. "pearson" or "spearman".}

\item{var_a}{a boolean indicator of whether to account for the variances in the diagonal matrix}

\item{cor_o}{a boolean indicator of whether to account for the correlations between the outcomes (obtained from cor1)}

\item{cor_t}{a boolean indicator of whether to account for the temporal correlations for the repeated measures}

\item{novarcor}{A matrix with the between outcome correlation. Leave as FALSE if you want to algorithm to calculate the covariance matrix.}

\item{standard}{Should each variable be globally standardized recursively before running algorithm at each iteration}

\item{fixmat}{a matrix specifying where clusters deviate. Works only when the "fixed" option is specified in the gapmethod parameter.}
}
\value{
Returns a nested list with data frames containing ID, repeated outcome in wide format, cluster partitions at each visit.
}
\description{
Performs clustering at each visit using the R-CHRM approach
}
\examples{
rchrmclus(arr=myarray, id=idvector, timevector=0:3, init_cols=1, B=500, method="scaledPCA", nlimit=20, imp="copyMean.locf", algo="kmeans", dis="Cholesky", gapdis="euclidean", gapmethod="globalSEmax", covmethod="pearson", var_a = TRUE, cor_o=TRUE, cor_t=TRUE, novarcor=FALSE,standard=FALSE, fixmat=FALSE)
Generate a MVN dataset (2 variable) using the createdata function
mymat <- createdata(p1_a=.5, E_a=c(.3,.4,.6,.4) ,s2_a=c(1,2,2,1,1,1,2,2), meanvalues=matrix(c(3,3,3,6,2,2,6,2,2,6,5,2,3,3,3,7,5,5,8,4,4,9,7,2), ncol=8), sizes=c(100,100,100))

Create a list separating the two variables
mylist <- list(mymat[,1:4], mymat[,5:8])

Create a vector of IDs associated with each row. Note that the vector should be sorted.
myid <- c(1001:1100,2001:2100, 3001:3100)

Invoke the recursive algorithm
aaa <- rchrmclus(arr=mylist, id=myid, timevector=0:3, init_cols=1, B=200, method="scaledPCA", nlimit=20, imp="copyMean.locf", algo="kmeans", dis="Cholesky", gapdis="euclidean", gapmethod="Tibs2001SEmax", covmethod="pearson", var_a = TRUE, cor_o=TRUE, cor_t=TRUE, novarcor=FALSE,standard=TRUE, fixmat=FALSE)

table(aaa[[1]][[1]]$cluster0)
table(aaa[[1]][[1]]$cluster1)
table(aaa[[1]][[1]]$cluster2)
table(aaa[[1]][[1]]$cluster3)
}
